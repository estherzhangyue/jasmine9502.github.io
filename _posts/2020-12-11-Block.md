---

title: Block

commentable: flase

Edit: 2020-12-11

mathjax: true

mermaid: true

tags: Block

categories: oc

description: Block

---

**block：**代码块，类似一个方法。

每一个方法都是在被调用的时候从硬盘到内存，然后去执行，执行完就消失，所以，方法的内存不需要管理，也就是说，方法是在内存的栈区。所以，block不像OC中的类对象(在堆区)，***他也是在栈区的***。

如果使用block作为一个对象的属性，会使用关键字copy修饰他，因为他在栈区，没办法控制他的消亡，当用copy修饰的时候，***系统会把该 block的实现拷贝一份到堆区，这样对应的属性，就拥有的该block的所有权***。<u>就可以保证block代码块不会提前消亡。</u>

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午1.40.35.png" alt="截屏2021-01-14 下午1.40.35" style="zoom:50%;" />



在实现block的时候，一般都会使用到外部(block大括号之外)变量。而局部变量(非静态)是不能在外部使用的，而block又类似是一个方法，那为什么可以使用外部变量呢。

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午1.43.02.png" style="zoom:50%;" />

因为OC是一种运行时语言，我们写的OC代码最终都是要转换成C语言的代码去执行的。我们通过运行时代码可以知道，系统会把使用到的外部变量通过参数列表传递给block，也就变成了block内部的局部变量，所以可以使用。

而在传递的时候，*对于基本数据类型的外部变量来说，系统默认传递的仅仅是值，也就是说**这个局部变量是不能修改的**。*如果想修改值，会使用__block来修饰这个变量。这样一来，系统在传递的时候，传的就是外部变量的地址，这样我们就可以修改值了。

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午2.42.38.png" alt="截屏2021-01-14 下午2.42.38" style="zoom:50%;" />

**对于对象类型，传递的是地址**，同时默认对该对象进行了一次强引用。系统进行了强引用，而他又对该对象的内存管理袖手旁观，也就是说，他只做了强引用，但是没有做释放操作。这个时候就会造成内存泄漏。

所以，我们在使用对象的时候，在MRC下，都会使用__block修饰，在ARC下，使用__**weak修饰**，这样一来，系统在传递的时候就不会对该对象进行强引用，避免了内存泄漏。

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午2.44.54.png" alt="截屏2021-01-14 下午2.44.54" style="zoom:50%;" />



举🌰，现在有A和B两个对象，其中A对象包含B对象，A如果想让B干什么，A只需要给B一个消息[B dosth],而此时，如果B对象想让A对象干什么事情呢，肯定是希望是给A一个消息[A dosth],但是B中没有A对象。

*那我们能不能给B一个属性是A对象呢，让B也包含A？*

显然不行，第一，B对象中的A对象不是包含B对象的那个A对象，第二 ，互相包含很可能会造成循环引用，最后两个对象都释放不了，造成***内存泄漏***。

***此时的解决方案是使用代理***，A包含B对象，当创建B对象的时候，A就把自己设为B的代理。那如果B给他的代理发消息，就能保证是包含他的那个A对象去接收消息了。同时，代理属性我们都是使用关键字weak,就是为了避免循环引用。

> 而block和代理的使用是一样的，只不过相对简单，不用制定协议、写代理方法。同时效率更高。



**当两个需要通信的对象之间有包含关系的时候，考虑代理和block**。比如，上面的A和B对象，**如果B想让A干不止一件事情，就用代理**。如果就是一件事情，没必要又制订协议，有些代理方法，太麻烦，此时可以考虑使用block。

有的时候，**需要通信的两个对象之间没有关系**，或者是一个对象要跟多个对象通信的时候，**就要用到通知了**。比如，旅游类app，如果在第一个界面改了城市名，那其他平行界面也要知道改了城市名，显示对应的数据，这个时候 就可以用通知。

//左侧声明，右侧定义

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.13.12.png" alt="截屏2021-01-14 下午4.13.12" style="zoom:50%;" />

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.14.54.png" alt="截屏2021-01-14 下午4.14.54" style="zoom:40%;" />

**Q:下述代码输出值为多少？**

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.26.14.png" alt="截屏2021-01-14 下午4.26.14" style="zoom:50%;" />

> 输出值为 age：10
>
> 原因：创建block的时候，已经把age的值存储在里面了。



**Q:下述代码输出值为多少？**

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.29.17.png" alt="截屏2021-01-14 下午4.29.17" style="zoom:50%;" />

> 输出结果为：age:10,num:11
>
> 原因：auto变量block访问方式是**值传递**，static变量block访问方式是指针传递
>
> static修饰的变量，是根据指针访问的
>
> auto自动变量可能会销毁的，内存可能会消失，不采用指针访问；
>
> static变量一直保存在内存中，指针访问即可



**Q：block对全局变量的捕获方式是？**

block不需要对全局变量捕获，都是直接采用取值的

block还可以访问外界的局部变量

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.32.13.png" alt="截屏2021-01-14 下午4.32.13" style="zoom:50%;" />

这里面就用到了`void(^animations)(void)`跟`void(^completion)(BOOL finished)`两个block，系统会在动画开始以及动画结束的时候分别调用者两个block。

在实现动画的block内部，代码访问了上文中的*center*属性——在动画开始的时候这个动画函数的生命周期早已结束，而block会捕获代码外的局部变量，当然这只局限于只读操作。如果我们在block中修改外部变量，编译器将会报错。

对于希望在block中修改的外界局部对象，我们可以给这些变量加上***__block***关键字修饰，这样就能在block中修改这些变量。在捕获变量特性中，还有一个有趣的小机制，我们把上面的代码改成这样：

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.37.41.png" alt="截屏2021-01-14 下午4.37.41" style="zoom:50%;" />



> block在捕获变量的时候只会保存变量被捕获时的状态（对象变量除外），之后即便变量再次改变，block中的值也不会发生改变。

所以上面的代码在计算新的坐标值时center的值依旧等于CGPointZero。

**Q：block有哪几种类型？**

block的类型，取决于isa指针，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型

- __NSGlobalBlock __ （ _NSConcreteGlobalBlock ）

- __NSStackBlock __ （ _NSConcreteStackBlock ）

- __NSMallocBlock __ （ _NSConcreteMallocBlock ）

  <img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.46.35.png" alt="截屏2021-01-14 下午4.46.35" style="zoom:50%;" />

> 输出结果：
>
> **NSGlobalBlock**
>
> __NSGlobalBlock
>
> NSBlock
>
> NSObject
>
> null



**Q：各类型的block在内存中如何分配的？**

- __NSGlobalBlock __ 在数据区

- __NSMallocBlock __ 在堆区

- __NSStackBlock __ 在栈区

  > 堆：动态分配内存，需要程序员自己申请，程序员自己管理
  >
  > 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况



**Q：对每种类型block调用copy操作后是什么结果？**

- __NSGlobalBlock __ 调用copy操作后，什么也不做
- __NSStackBlock __ 调用copy操作后，复制效果是：从栈复制到堆；副本存储位置是**堆**
- __NSStackBlock __ 调用copy操作后，复制效果是：引用计数增加；副本存储位置是**堆**



**Q：block能否修改变量值？**

**auto修饰变量**，block无法修改，因为block使用的时候是内部创建了变量来保存外部的变量的值，block只有修改内部自己变量的权限，无法修改外部变量的权限。

**static修饰变量**，block可以修改，因为block把外部static修饰变量的指针存入，block直接修改指针指向变量值，即可修改外部变量值。

**全局变量值**，全局变量无论哪里都可以修改，当然block内部也可以修改。



**Q:   循环引用**

block在iOS开发中被视作是对象，因此其生命周期会一直等到持有者的生命周期结束了才会结束。另一方面，由于block捕获变量的机制，使得持有block的对象也可能被block持有，从而形成循环引用，导致两者都不能被释放:

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.39.28.png" alt="截屏2021-01-14 下午4.39.28" style="zoom:50%;" />

遇到这种代码编译器只会告诉你存在警告，很多时候我们都是忽略警告的，这最后会导致内存泄露，两者都无法释放。跟普通变量存在__block关键字一样的，系统提供给我们__weak的关键字用来修饰对象变量，声明这是一个弱引用的对象，从而解决了循环引用的问题：

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.41.48.png" alt="截屏2021-01-14 下午4.41.48" style="zoom:50%;" />



**1.第一种方式：__weak**

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.49.05.png" alt="截屏2021-01-14 下午4.49.05" style="zoom:50%;" />

**2.第二种方式：__unsafe_unretained**

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.49.30.png" alt="截屏2021-01-14 下午4.49.30" style="zoom:50%;" />

**3.第三种方式：__block**

<img src="/Users/zhangyue/Desktop/截屏2021-01-14 下午4.49.58.png" alt="截屏2021-01-14 下午4.49.58" style="zoom:50%;" />



**三种方法比较**

> - __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil
> - __unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变
> - __block：必须把引用对象置位nil，并且要调用该block